# -*- coding: utf-8 -*-
# dims.py: Shape compatibility in nodes
# author : Antoine Passemiers

from oriana.exceptions import IncompatibleShapeException

import numpy as np
from functools import reduce


class DimRelation:
    """Contains the tools necessary for a ProbabilisticNode
    to ensure shape compatibility between node buffer,
    sample array, pdf array, etc.

    The product of dimensions in `shape` must be equal to the
    product of `n_samples_per_distrib`, `n_distribs` and
    `n_components`.

    Attributes:
        shape (tuple): Shape of the node's buffer.
        n_samples_per_distrib (int): Number of samples
            to be generated by each instance of the distribution.
        n_distribs (int): Number of instances of the distribution.
        n_components (int): Number of components in each
            distribution. Univariate distributions like
            Poisson, Gamma or Bernoulli have only one component.
            A multivariate Gaussian of k variables has k components.
        reshape_func (function): Reshapes an array of shape
            (`n_samples_per_distrib`, `n_distribs`, `n_components`)
            to an array of shape `shape`.
        inv_reshape_func (function): Reshapes an array of shape
            `shape` to an array of shape
            (`n_samples_per_distrib`, `n_distribs`, `n_components`).
    """

    def __init__(self, shape, n_samples_per_distrib,
                 n_distribs, n_components, reshape_func,
                 inv_reshape_func):
        self.shape = shape
        self.n_samples_per_distrib = n_samples_per_distrib
        self.n_distribs = n_distribs
        self.n_components = n_components
        self.reshape_func = reshape_func
        self.inv_reshape_func = inv_reshape_func

    def __repr__(self):
        """String representation of the dim relation.

        Input shape is indicated on the left of the arrow
        and the output shape on the right.

        Returns:
            str: String representation
        """
        s = self.n_samples_per_distrib
        d = self.n_distribs
        c = self.n_components
        return 'Dimension mapping ' + str(self.shape) + \
            ' <-> ' + str((s, d, c))


class Dimensions:
    """Mapping between dimension names and their respective values.

    Attributes:
        dims (dict): Dictionnary where keys are dimension names
            and values are integers.

    Example:
        >>> dims = Dimensions({ 'n': n, 'm': m, 'p': p })
    """

    def __init__(self, dims):
        self.dims = dims

    def __call__(self, rel):
        """Instantiates a specific relation between some of the
        dimensions in `self`.

        Parameters:
            rel (str): String of the form 'left ~ right' where
                'left' are comma-delimited dimension names
                and 'right' are comma-delimited characters
                belonging to { 's', 'd', 'c' }.

        Returns:
            :obj:`oriana.DimRelation`: Dimension mapping.

        Example:
            >>> dims = Dimensions({ 'n': 10, 'm': 5, 'p': 5, 'k': 3, 'l': 4 })
            >>> dims('m,k ~ d,s')
            Dimension mapping (5, 3) <-> (3, 5, 1)
            >>> dims('n,k ~ s,d')
            Dimension mapping (10, 3) <-> (10, 3, 1)
            >>> dims('m,k ~ s,d')
            Dimension mapping (5, 3) <-> (5, 3, 1)
            >>> dims('n,m,k ~ d,d,d')
            Dimension mapping (10, 5, 3) <-> (1, 150, 1)
            >>> dims('n,k,l,l ~ s,d,c,c')
            Dimension mapping (10, 3, 4, 4) <-> (10, 3, 16)
        """
        # Split string into left-hand side (lhs) and right-hand side (rhs)
        sides = rel.split('~')
        lhs, rhs = sides[0].strip(), sides[1].strip()
        lhs, rhs = lhs.split(','), rhs.split(',')
        if len(lhs) != len(rhs):
            raise IncompatibleShapeException(
                'Relation "%s" format is not correct.' % rel)
        
        # lhs is the shape of the node's buffer
        shape = tuple([self.dims[key] for key in lhs])

        # Find positions of 's', 'd' and 'c' in rhs
        s_indices = [i for i, symbol in enumerate(rhs) if symbol == 's']
        d_indices = [i for i, symbol in enumerate(rhs) if symbol == 'd']
        c_indices = [i for i, symbol in enumerate(rhs) if symbol == 'c']
        in_indices = s_indices + d_indices + c_indices

        # Group dimensions by symbol ('s', 'd' or 'c')
        mul = lambda x, y: x * y
        s_shape = [self.dims[lhs[i]] for i in s_indices]
        n_samples_per_distrib = reduce(mul, [1] + s_shape)
        d_shape = [self.dims[lhs[i]] for i in d_indices]
        n_distribs = reduce(mul, [1] + d_shape)
        c_shape = [self.dims[lhs[i]] for i in c_indices]
        n_components = reduce(mul, [1] + c_shape)

        # Define target shapes
        in_shape = (n_samples_per_distrib, n_distribs, n_components)
        intermediary_shape = tuple(s_shape + d_shape + c_shape)

        # Define how to reshape an array of shape
        # (`n_samples_per_distrib`, `n_distribs`, `n_components`)
        # to an array of shape `shape`.
        def reshape(data):
            assert(data.shape == in_shape)
            data = data.reshape(*intermediary_shape, order='C')
            return np.transpose(data, in_indices)

        # Define how the reshape an array of shape `shape`
        # to an array of shape
        # (`n_samples_per_distrib`, `n_distribs`, `n_components`).
        def inv_reshape(data):
            assert(data.shape == shape)
            inv_in_indices = [in_indices.index(i) for i in range(len(in_indices))]
            data = np.transpose(data, inv_in_indices)
            return data.reshape(*in_shape, order='C')

        return DimRelation(shape, n_samples_per_distrib,
                           n_distribs, n_components, reshape, inv_reshape)

    def __setitem__(self, key, value):
        """Set dimension by its name `key`.

        Parameters:
            key (str): Dimension name.
            value (int): Value of the dimension
        """
        self.dims[key, value]

    def __getitem__(self, key):
        """Get dimension by its name `key`.

        Parameters:
            key (str): Dimension name.
        """
        return self.dims[key]
